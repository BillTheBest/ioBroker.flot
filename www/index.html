<head>
    <title>Flot Chart</title>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <link href="img/favicon.png" rel="shortcut icon" type="image/x-icon" />

    <!--link type="text/css" rel="stylesheet" href="/lib/css/themes/jquery-ui/default/jquery-ui.min.css"-->

    <script src="/lib/js/jquery-1.11.1.min.js"></script>
    <!--script src="/lib/js/jquery-ui.1.11.2.slider.min.js"></script-->
    <script src="/lib/js/socket.io.js"></script>

    <script src="lib/js/jquery.flot.min.js"></script>
    <script src="lib/js/jquery.flot.resize.min.js"></script>
    <script src="lib/js/jquery.flot.time.min.js"></script>
    <script src="lib/js/jquery.flot.categories.min.js"></script>
    <script src="lib/js/jquery.flot.pie.min.js"></script>
    <script src="lib/js/JUMFlot.min.js"></script>
    <script src="lib/js/curvedLines.js"></script>
    <script src="lib/js/jquery.flot.selection.min.js"></script>
    <script src="lib/js/jquery.flot.hiddengraphs.js"></script>
    <script src="lib/js/jquery-deparam.js"></script>
    <script src="lib/js/jquery.flot.navigate.min.js"></script>
    <script src="/_socket/info.js"></script>
    <style>
        .rickshaw_graph .x_tick.invisible {
            border-left: 0 rgba(0, 0, 0, 0) !important;
        }

        #title {
            font-size: 24px;
            font-weight: bold;
        }

        div, span, p, td {
            font-family: Arial, sans-serif;
        }

        #chart {
            display: inline-block;
        }

        #legend_container {
            position: absolute;
            right: 0;
            bottom: 26px;
            width: 0;
        }

        .chart-container {
            box-sizing: border-box;
            padding: 20px 15px 15px 15px;
            /*margin: 15px auto 30px auto;*/
            border: 1px solid #ddd;
            background: #fff;
            background: linear-gradient(#f6f6f6 0, #fff 50px);
            background: -o-linear-gradient(#f6f6f6 0, #fff 50px);
            background: -ms-linear-gradient(#f6f6f6 0, #fff 50px);
            background: -moz-linear-gradient(#f6f6f6 0, #fff 50px);
            background: -webkit-linear-gradient(#f6f6f6 0, #fff 50px);
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.15);
            -o-box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1);
            -ms-box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1);
            -moz-box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1);
            -webkit-box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1);
        }

        .chart-placeholder {
            width: 100%;
            height: 100%;
            font-size: 14px;
            line-height: 1.2em;
        }

        /* ------------------ connecting -------------------------- */
        #server-disconnect {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            overflow: hidden;
            background-color: rgba(231,231,231,0.9) !important;
            background-size: 100% !important;
            background-position: center !important;
            background-repeat: no-repeat !important;
            z-index: 5000;
        }

        #server-disconnect > * {
            /* center child divs  */
            position: absolute;
            top: 50%;
            left: 50%;
            /* x-border-box */
            box-sizing: border-box;
            -moz-box-sizing: border-box;
            -ms-box-sizing: border-box;
            -webkit-box-sizing: border-box;
            /* x-unselectable */
            user-select: none;
            -o-user-select: none;
            -ms-user-select: none;
            -moz-user-select: -moz-none;
            -webkit-user-select: none;
            cursor: default;
        }
        .splash-screen-circle-outer {
            z-index: 20000;
            width: 100px;
            height: 100px;
            border-radius: 100px;
            margin-top: -50px;
            margin-left: -50px;
            border: 5px solid rgba(87, 113, 145, 0.9);
            opacity: .9;
            border-right: 5px solid rgba(0, 0, 0, 0);
            border-left: 5px solid rgba(0, 0, 0, 0);
            box-shadow: 0 0 35px #577191;
            -moz-animation: spinPulse 5s infinite ease-in-out;
            -webkit-animation: spinPulse 5s infinite linear;
        }
        .splash-screen-circle-inner {
            z-index: 20001;
            width: 80px;
            height: 80px;
            border-radius: 80px;
            margin-top: -40px;
            margin-left: -40px;
            background-color: rgba(0, 0, 0, 0);
            border: 5px solid rgba(87, 113, 145, 0.9);
            opacity: .9;
            border-left: 5px solid rgba(0, 0, 0, 0);
            border-right: 5px solid rgba(0, 0, 0, 0);
            box-shadow: 0 0 15px #577191;
            -moz-animation: spinoffPulse 5s infinite linear;
            -webkit-animation: spinoffPulse 5s infinite linear;
        }
        .splash-screen-text {
            z-index: 20002;
            width: 100px;
            height: 100px;
            line-height: 100px;
            margin-top: -50px;
            margin-left: -50px;
            font-family: Verdana, Geneva, sans-serif;
            font-size: 13px;
            text-align: center;
            text-shadow: 1px 1px #cccccc;
            vertical-align: middle;
            color: #002951;
        }
        @-moz-keyframes spinPulse {
            0% {
                -moz-transform: rotate(160deg);
                opacity: 0;
                box-shadow: 0 0 1px #577191;
            }
            50% {
                -moz-transform: rotate(145deg);
                opacity: 1;
            }
            100% {
                -moz-transform: rotate(-320deg);
                opacity: 0;
            }
        }
        @-moz-keyframes spinoffPulse {
            0% {
                -moz-transform: rotate(0deg);
            }
            100% {
                -moz-transform: rotate(360deg);
            }
        }
        @-webkit-keyframes spinPulse {
            0% {
                -webkit-transform: rotate(160deg);
                opacity: 0;
                box-shadow: 0 0 1px #577191;
            }
            50% {
                -webkit-transform: rotate(145deg);
                opacity: 1;
            }
            100% {
                -webkit-transform: rotate(-320deg);
                opacity: 0;
            }
        }
        @-webkit-keyframes spinoffPulse {
            0% {
                -webkit-transform: rotate(0deg);
            }
            100% {
                -webkit-transform: rotate(360deg);
            }
        }

    </style>
</head>
<body>

<div id="chart_container">
    <div id="server-disconnect">
        <div class="splash-screen-text">...</div>
        <div class="splash-screen-circle-outer"></div>
        <div class="splash-screen-circle-inner"></div>
    </div>
    <div id="no-connection"
         style="position:absolute; left: 50%; top: 50%; display: none; font-size: 3em; background: rgba(0, 0, 0, 0.1); border-radius: 10px; text-align: center">
        No connection to server
    </div>
    <div id="chart_placeholder" class="chart-placeholder"></div>
    <div id="title" style="position:absolute"></div>
</div>
<!--<div id="nav-bar" style="position: relative">-->
    <!--<button id="navLeft"  style="position: absolute; right:50px">right</button>-->
    <!--<button id="navNow"  onclick="navNow()" style="position: absolute; right:50%">now</button>-->
    <!--<button id="navRight" style="position: absolute; left:50px">left</button>-->
<!--</div>-->
    <img style="position: absolute; right: 50%; top: 20px; z-index: 10; display: none; cursor: pointer" src="img/resetZoom.png" title="Reset zoom" id="resetZoom"/>
<script>
    var graph;

    var backgrounds = [
        ['#8e9eab', '#eef2f3'], // Portrait
        ['#517fa4', '#243949'], // Instagram
        ['#485563', '#29323c'], // ServQuick
        ['#abbaab', '#00ffff'], // Metallic Toad
        ['#ECE9E6', '#00ffff'], // Clouds
        ['#16222A', '#3A6073'], // Mirage
        ['#1F1C2C', '#928DAB'], // Steel Gray
        ['#003973', '#E5E5BE'], // Horizon
        ['#D1913C', '#FFD194'], // Koko Caramel
        ['#136a8a', '#267871']  // Turquoise flow
    ];

    // Show "no connection" message after 5 seconds
    var disconnectTimeout = setTimeout(function () {
        disconnectTimeout = null;
        //Show disconnected message
        $('#no-connection').show();
    }, 5000);

    var zoomTimeout = null;

    // Analyse query
    var path = location.href.split('?')[1];

    // convert old format to new one
    // OLD: http://localhost:8082/flot/index.html?range=1440&renderer=line&axeX=l&axeY=inside&_ids=system.adapter.admin.0.memRss%2Csystem.adapter.email.0.memRss&_colors=%23c05020%3B%2330c020%3B%236060c0
    // NEW: http://localhost:8082/flot/index.html?l%5B0%5D%5Bid%5D=system.adapter.admin.0.memRss&l%5B0%5D%5Boffset%5D=0&l%5B0%5D%5Bart%5D=average&l%5B0%5D%5Bcolor%5D=%23FF0000&l%5B0%5D%5Bthickness%5D=3&l%5B1%5D%5Bid%5D=system.adapter.email.0.memRss&l%5B1%5D%5Boffset%5D=0&l%5B1%5D%5Bart%5D=average&l%5B1%5D%5Bcolor%5D=%2300FF00&l%5B1%5D%5Bthickness%5D=3&timeArt=relative&relativeEnd=now&range=10&aggregateType=step&aggregateSpan=300&legend=sw
    // OLD =>
    //{
    //    _colors: "#c05020;#30c020;#6060c0"
    //    _ids: "system.adapter.admin.0.memRss,system.adapter.email.0.memRss"
    //    axeX: "lines"
    //    axeY: "inside"
    //    range: "1440"
    //    renderer: "line"
    //}
    // NEW =>
    //{
    //  "l" : [
    //     {
    //        "id" : "system.adapter.admin.0.memRss",
    //        "offset" : "0",
    //        "art" : "average",
    //        "color" : "#FF0000",
    //        "thickness" : "3"
    //      }, {
    //        "id" : "system.adapter.email.0.memRss",
    //        "offset" : "0",
    //        "art" : "average",
    //        "color" : "#00FF00",
    //        "thickness" : "3"
    //      }
    //  ],
    //    "timeArt" : "relative",
    //    "relativeEnd" : "now",
    //    "range" : "10",
    //    "aggregateType" : "step",
    //    "aggregateSpan" : "300",
    //    "legend" : "sw    //}

    var config = deparam(path || '');

    if (config.lines) {
        config.l = JSON.parse(JSON.stringify(config.lines));
        delete config.lines;
    }

    if (config._ids) {
        var ids    = config._ids    ? config._ids.split(';')    : [];
        var colors = config._colors ? config._colors.split(';') : [];
        var names  = config._names  ? config._names.split(';')  : [];
        var units  = config._units  ? config._units.split(';')  : [];
        config.l = [];
        for (var i = 0; i < ids.length; i++) {
            config.l.push({
                id:         ids[i],
                offset:     0,
                name:       names[i] || '',
                art:        "average",
                color:      colors[i] || 'blue',
                thickness:  config.strokeWidth || 1,
                shadowsize: config.strokeWidth || 1,
                min:        config.min || '',
                max:        config.max || '',
                unit:       units[i]   || ''
            });
        }
        config.range = parseInt(config.range, 10);
        config.aggregateType = "step";
        config.aggregateSpan = 300;
        config.relativeEnd   = "now";
    }

    // Set default values
    config.longestStep = 0;
    config.width        = config.width  || '100%';
    config.height       = config.height || '100%';
    config.timeFormat   = config.timeFormat || "%H:%M:%S %e.%m.%y";
    config.useComma     = config.useComma === 'true' || config.useComma === true;
    config.zoom         = config.zoom     === 'true' || config.zoom     === true;
    config.afterComma   = (config.afterComma === undefined) ? 2 : config.afterComma;
    //    if ((config.max !== undefined && config.max != '' && parseFloat(config.max) != NaN)) config.max = parseFloat(config.max);
    var seriesData      = [];
    var series          = [];
    var settings        = [];
    var liveInterval;

    var navOptions      = {};
    var socketURL       = '';
    var socketSESSION   = '';
    var now             = new Date();

    if (config.window_bg) $('body').css('background', config.window_bg);

    if (typeof socketUrl != 'undefined') {
        socketURL = socketUrl;
        if (socketURL && socketURL[0] == ':') {
            socketURL = 'http://' + location.hostname + socketURL;
        }
        socketSESSION = socketSession;
    }

    var socket = io.connect(socketURL, {
        'query':                        'key=' + socketSESSION,
        'reconnection limit':           10000,
        'max reconnection attempts':    Infinity
    });

    socket.on('connect', function () {
        socket.emit('name', 'flot');
        if (disconnectTimeout) {
            $('#no-connection').hide();
            clearTimeout(disconnectTimeout);
            disconnectTimeout = null;
        }
        readData();
    });

    socket.on('disconnect', function () {
        if (!disconnectTimeout) {
            disconnectTimeout = setTimeout(function () {
                disconnectTimeout = null;
                //Show disconnected message
                $('#no-connection').show();
            }, 5000);
        }
    });

    function getStartStop(index, step) {
        var option = {};
        var end;
        var start;
        config.l[index].offset = config.l[index].offset || 0;

        if (config.zoomed) {
            navOptions[index].end   = config.l[index].zMax;
            navOptions[index].start = config.l[index].zMin;
            return navOptions[index];
        } else {
            if (!step) {
                if (config.timeArt == 'static') {
                    if (config.start_time != undefined) {
                        var start_time = config.start_time.split(':').map(Number);
                    } else {
                        var start_time = [0, 0];
                    }

                    if (config.end_time != undefined) {
                        var end_time = config.end_time.split(':').map(Number);
                    } else {
                        var end_time = [24, 0];
                    }

                    // offset is in seconds
                    start = Math.round(new Date(config.start).setHours(start_time[0], start_time[1]) / 1000) - config.l[index].offset;
                    end   = Math.round(new Date(config.end)  .setHours(end_time[0],   end_time[1])   / 1000) - config.l[index].offset;

                } else {
                    if (config.relativeEnd == 'now') {
                        end   = Math.round(now.getTime() / 1000) - (config.l[index].offset || 0);
                        start = end - (config.range * 60);
                    } else if (config.relativeEnd == 'today') {
                        var _now = new Date(now);
                        end   = Math.round(_now.setHours(24).getTime() / 1000) - config.l[index].offset;
                        start = Math.round(new Date(new Date(_now).setMinutes(0)).setSeconds(0).getTime() / 1000) - (config.range * 60) - config.l[index].offset;
                    }
                }

                option = {
                    start:      start, // todo return here * 1000
                    end:        end,   // todo return here * 1000
                    ignoreNull: false,
                    aggregate:  config.l[index].art || 'average'
                };

                if (config.aggregateType == 'step') {
                    option.step = config.aggregateSpan;
                } else if (config.aggregateType == 'count') {
                    option.count = config.aggregateSpan || document.getElementById('chart_container').clientWidth;
                }

                navOptions[index] = option;
                return option;

            } else {

                end   = Math.round(now.getTime() / 1000) - config.l[index].offset;
                start = end - (step);

                option = {
                    start:      start, // todo return here * 1000
                    end:        end,   // todo return here * 1000
                    ignoreNull: false,
                    aggregate:  config.l[index].art || 'average',
                    count:      1
                };

                navOptions[index].end   = end;
                navOptions[index].start = end - (config.range * 60);
                return option;
            }
        }
    }

    function readOneChart(id, instance, index, callback) {

        var option = getStartStop(index);
        option.instance = instance;
        config.l[index].yOffset = parseFloat(config.l[index].yOffset) || 0;

        //console.log(JSON.stringify(option));
        console.log(new Date(option.start * 1000) + ' - ' + new Date(option.end * 1000));
        socket.emit('getHistory', id, option, function (err, res, step) {
            if (!err && res) {
                //for (var i = 0, len = res.length; i < len; i++) {
                option.start = option.start * 1000;
                option.end   = option.end   * 1000;
                option.ignoreNull = (config.l[index].ignoreNull === undefined) ? (config.ignoreNull === 'true' || config.ignoreNull === true) : (config.l[index].ignoreNull === 'true' || config.l[index].ignoreNull === true);
                option.yOffset = config.l[index].yOffset;

                if (config.longestStep < step) config.longestStep = step;
                if (res.length && res[0].ts < 946681200000) config.longestStep *= 1000;

                var lastVal = null;
                var preFirstValue = null;
                var postLastValue = null;
                for (var i = 0; i < res.length; i++) {
                    // if less 2000.01.01 00:00:00
                    if (res[i].ts < 946681200000) res[i].ts = res[i].ts * 1000;

                    // Convert boolean values to numbers
                    if (res[i].val === 'true' || res[i].val === true) {
                        res[i].val = 1;
                    } else if (res[i].val === 'false' || res[i].val === false) {
                        res[i].val = 0;
                    }
                    if (typeof res[i].val == 'string') res[i].val = parseFloat(res[i].val);

                    if (res[i].val === null) {
                        if (option.ignoreNull || i == res.length - 1) res[i].val = lastVal;
                    } else {
                        lastVal = res[i].val;
                    }
                    // remove all not requested points
                    if (res[i].ts < option.start) {
                        preFirstValue = res[i].val !== null ? res[i].val + option.yOffset : null;
                        continue;
                    }
                    if (res[i].ts > option.end) {
                        postLastValue = res[i].val !== null ? res[i].val + option.yOffset : null;
                        break;
                    }

                    if (res[i].val !== null/* || i == 0 || i == res.length - 1*/) {
                        seriesData[index].push([res[i].ts, res[i].val + option.yOffset]);
                        postLastValue = res[i].val + option.yOffset;
                    }
                }
                // check start and stop
                if (!seriesData[index][0] || seriesData[index][0][0] > option.start) seriesData[index].unshift([option.start, preFirstValue]);
                if (seriesData[index][seriesData[index].length - 1][0] < option.end) seriesData[index].push([option.end, postLastValue]);
            }

            if (callback) callback(id, index);
        });
    }

    function yFormatter(y) {
        if (typeof y === 'boolean') return '' + y;
        if (config.afterComma !== undefined && config.afterComma !== null) {
            y = parseFloat(y);
            if (config.useComma) {
                return y.toFixed(config.afterComma).toString().replace('.', ',');
            } else {
                return y.toFixed(config.afterComma);
            }
        } else {
            if (config.useComma) {
                y = parseFloat(y);
                return y.toString().replace('.', ',');
            } else {
                return y;
            }
        }
    }

    function readOneValue(id, index, callback) {
        socket.emit('getObject', id, function (err, res) {
            if (!err && res && res.common) {
                config.l[index].name = config.l[index].name || res.common.name;
                config.l[index].unit = config.l[index].unit || (res.common.unit ? res.common.unit.replace('�', '°') : '');
                config.l[index].type = res.common.type;
            } else {
                config.l[index].name = config.l[index].name || id;
                config.l[index].unit = config.l[index].unit || '';
            }

            socket.emit('getState', id, function (err, state) {
                if (state) {
                    callback(id, index, state.val);
                } else {
                    callback(id, index, null)
                }
            });
        });
    }

    function readData(hidden) {
        if (disconnectTimeout) {
            $('#no-connection').hide();
            clearTimeout(disconnectTimeout);
            disconnectTimeout = null;
        }

        if (config.l) {
            if (!hidden) $('#server-disconnect').show();

            // todo
//            if (config.renderer == 'pie' || (config.renderer == 'bar' && config._ids.length > 1)) {
//
//                seriesData = [[]];
//                for (var j = 0; j < config._ids.length; j++) {
//                    readOneValue(config._ids[j], j, function (_id, _index, value) {
//                        if (config.renderer == 'pie') {
//                            seriesData[0][_index] = {label: config.l[_index].name, data: value};
//                        } else {
//                            seriesData[0][_index] = [config.l[_index].name, value];
//                        }
//                        if (_index == config._ids.length - 1) {
//                            buildGraph();
//                        }
//                    });
//                }
//            } else {
            var j;
            for (j = 0; j < config.l.length; j++) {
                if (config.l[j] !== '' && config.l[j] !== undefined) seriesData.push([]);
            }
            var ready = 0;

            function _readOneLine(index) {
                ready++;
                socket.emit('getObject', config.l[index].id, function (err, res) {
                    if (!err && res && res.common) {
                        config.l[index].name = config.l[index].name || res.common.name;
                        config.l[index].unit = config.l[index].unit || (res.common.unit ? res.common.unit.replace('�', '°') : '');
                        config.l[index].type = res.common.type;
                    } else {
                        config.l[index].name = config.l[index].name || config.l[index].id;
                        config.l[index].unit = config.l[index].unit || '';
                    }
                    readOneChart(config.l[index].id, config.l[index].instance, index, function () {
                        if (!--ready) {
                            $('#server-disconnect').hide();
                            buildGraph();
                        }
                    });
                });
            }

            for (j = 0; j < config.l.length; j++) {
                _readOneLine(j);
            }
        }
    }
    
    function onZoom() {
        var opt = graph.getOptions();
        if (!config.zoomed) {
            $('#resetZoom').show();
            config.zoomed = true;
        }
        for (var index = 0; index < opt.xaxes.length; index++) {
            config.l[index].zMin = Math.round(opt.xaxes[index].min / 1000);
            config.l[index].zMax = Math.round(opt.xaxes[index].max / 1000);
            settings.xaxes[index].max = opt.xaxes[index].max;
            settings.xaxes[index].min = opt.xaxes[index].min;
        }

        console.log('on zoom');
        updateLive();
    }

    function buildGraph() {
        series = [];
        var $title = $('#title');

        if (config.title && !$title.html()) {
            $title.html(decodeURI(config.title));
            if (config.titleColor) $title.css('color',    config.titleColor);
            if (config.titleSize) $title.css('font-size', config.titleSize);
            if (config.titlePos) {
                var parts = config.titlePos.split(';');
                var css = {};
                for (var t = 0; t < parts.length; t++) {
                    var p = parts[t].split(':');

                    // Bottom inside
                    if (p[0] == 'bottom' && p[1] == '5') {
                        if (config.height.indexOf('%') == -1) {
                            css.top = parseInt(config.height, 10) - $title.height() - 45;
                        } else {
                            css.top = 'calc(' + config.height + ' - ' + ($title.height() + 45) + 'px)';
                        }
                    } else	// Bottom outside
                    if (p[0] == 'bottom' && p[1] == '-5') {
                        if (config.height.indexOf('%') == -1) {
                            css.top = parseInt(config.height, 10) + 5;
                        } else {
                            css.top = 'calc(' + config.height + ' + 5px)';
                        }
                    } else	// Middle
                    if (p[0] == 'top' && p[1] == '50') {
                        if (config.height.indexOf('%') == -1) {
                            css.top = (parseInt(config.height, 10) - $title.height()) / 2;
                        } else {
                            css.top = 'calc(50% - ' + ($title.height() / 2) + 'px)';
                        }
                    } else	// Center
                    if (p[0] == 'left' && p[1] == '50') {
                        if (config.width.indexOf('%') == -1) {
                            css.left = (parseInt(config.width, 10) - $title.width()) / 2;
                        } else {
                            css.left = 'calc(50% - ' + ($title.width() / 2) + 'px)';
                        }
                    } else	// Right inside
                    if (p[0] == 'right' && p[1] == '5') {
                        if (config.width.indexOf('%') == -1) {
                            css.left = parseInt(config.width, 10) - $title.width() - 45;
                        } else {
                            css.left = 'calc(' + config.width + ' - ' + ($title.width() + 45) + 'px)';
                        }
                    } else	// Right outside
                    if (p[0] == 'right' && p[1] == '-5') {
                        if (config.width.indexOf('%') == -1) {
                            css.left = parseInt(config.width, 10) + 25;
                        } else {
                            css.left = 'calc(' + config.width + ' + 5px)';
                        }
                    } else {
                        css[p[0]] = p[1];
                    }
                }

                $title.css(css);
            }
        }

        // Replace background
        if (config.bg && config.bg.length < 3 && backgrounds[config.bg]) config.bg = {colors: backgrounds[config.bg]};

        //todo make bar working
//        if (config.renderer != 'bar' || config._ids.length <= 1) {

        for (var i = 0; i < seriesData.length; i++) {
            if (seriesData[i]) {

                config.l[i].chartType = config.l[i].chartType || 'line';

                var option = {
                    color:      config.l[i].color || undefined,
                    lines: {
                        show:       (config.l[i].chartType != 'scatterplot' && config.l[i].chartType != 'bar'),
                        fill:       (config.l[i].chartType == 'area' || config.l[i].chartType == 'bar'),
                        steps:      (config.l[i].chartType == 'steps'),
                        lineWidth:  config.l[i].thickness
                    },
                    bars: {
                        show:       (config.l[i].chartType == 'bar'),
                        barWidth:   0.6
                    },
                    points: {
                        show:       (config.l[i].chartType == 'lineplot' || config.l[i].chartType == 'scatterplot')
                    },
                    data:       seriesData[i],
                    label:      config.l[i].name,
                    shadowSize: config.l[i].shadowsize
                };

                if (config.smoothing > 0) {
                    config.smoothing = parseInt(config.smoothing);

                    if (config.smoothing > 1) {
                        option.data = $.plot.JUMlib.prepareData.avg(option.data, config.smoothing);
                    }
                    option.data = $.plot.JUMlib.prepareData.avg(option.data, config.smoothing);
                } else {
                    config.smoothing = 0;
                }
                if (config.l[i].chartType == 'bar') {
                    option.bars.barWidth = (option.data[option.data.length - 1][0] - option.data[0][0]) / option.data.length * 0.5;
                }

                series.push(option);
            }
        }

        if (config.min === null || config.min === undefined || config.min === '' || config.min.toString() === 'NaN') {
            config.min = undefined;
        } else {
            config.min = parseFloat(config.min);
        }

        if (config.noBorder) {
            if (!config.width)  config.width  = '100%';
            if (!config.height) config.height = '100%';

            if (config.width.indexOf('%') != -1) {
                $('#chart_container').css({width: 'calc(' + config.width + ' - 20px)'}); // original 20px
            } else {
                $('#chart_container').css({width: config.width});
            }
            if (config.height.indexOf('%') != -1) {
                $('#chart_container').css({height: 'calc(' + config.height + ' - 20px)'});// original 20px
            } else {
                $('#chart_container').css({height: config.height});
            }

        } else {
            $('#chart_container').addClass('chart-container').css({width: config.width, height: config.height});
//            $('#chart_container').css({'padding-bottom':"100px"})
        }

        if (config.timeFormat === 'null') config.timeFormat = undefined;

        if (config.timeFormat) {
            if (config.timeFormat.indexOf('%H:%M:%S') != -1) {
                config.timeFormatTime = '%H:%M:%S';
            } else if (config.timeFormat.indexOf('%I:%M:%S') != -1) {
                config.timeFormatTime = '%I:%M:%S';
            } else if (config.timeFormat.indexOf('%H:%M') != -1) {
                config.timeFormatTime = '%H:%M';
            } else {
                config.timeFormatTime = null;
            }
            if (config.timeFormat.indexOf('%d.%m.%y') != -1) {
                config.timeFormatDate = '%d.%m.%y';
            } else if (config.timeFormat.indexOf('%x %p') != -1) {
                config.timeFormatDate = '%x %p';
            } else if (config.timeFormat.indexOf('%d/%m/%y') != -1) {
                config.timeFormatDate = '%d/%m/%y';
            } else if (config.timeFormat.indexOf('%m.%d.%y') != -1) {
                config.timeFormatDate = '%m.%d.%y';
            } else if (config.timeFormat.indexOf('%d.%m') != -1) {
                config.timeFormatDate = '%d.%m';
            } else {
                config.timeFormatDate = null;
            }
        }

//        if (config.l[i].chartType == 'pie') {
//            series.legend = {
//                show: !!config.legend,
//                position: config.legend
//            };
//            graph = $.plot("#chart_placeholder", seriesData[0], series);
//        } else if (config.l[i].chartType == 'bar' && config._ids.length > 1) {
//            var series = {
//                series: {
//                    bars: {
//                        show: config.l[i].chartType == 'bar',
//                        barWidth: 0.6,
//                        align: "center"
//                    },
//                    pie: {
//                        show: config.l[i].chartType == 'pie'
//                    },
//                    legend: {
//                        show: !!config.legend,
//                        position: config.legend
//                    }
//                }
//            };
//
//            series.xaxis = {
//                mode: "categories",
//                tickLength: 0
//            };
//
//            graph = $.plot("#chart_placeholder", [seriesData[0]], series);
//        } else {

        settings = {
            grid: {
                hoverable:       (config.hoverDetail === 'true' || config.hoverDetail === true),
                backgroundColor: config.bg || undefined
            },
            yaxes: [],
            xaxes: [],
            legend: {
                show:       !!config.legend,
                position:   config.legend,
                hideable:   true
            }
        };

        if (config.zoom) {
            $('#resetZoom').unbind('click').click(function () {
                seriesData = [];
                $('#resetZoom').hide();
                config.zoomed = false;
                now = new Date();
                readData(true);
            });
            settings.zoom = {
                interactive: true,
                trigger:    'dblclick', // or "click" for single click
                amount:     1.5         // 2 = 200% (zoom in), 0.5 = 50% (zoom out)
            };
            settings.pan = {
                interactive: true,
                cursor:     'move',     // CSS mouse cursor value used when dragging, e.g. "pointer"
                frameRate:  20
            };
        }

        for (var ii = 0; ii < config.l.length; ii++) {

            config.l[ii].yaxe = config.l[ii].yaxe || '';
            config.l[ii].xaxe = config.l[ii].xaxe || '';
            config.l[ii].commonYAxis = config.l[ii].commonYAxis || '';

            var yaxi = {
                show: config.l[ii].yaxe == 'off' ? false : true,
                min:  config.l[ii].min,
                max:  config.l[ii].max,
                position: config.l[ii].yaxe.indexOf('left') > -1 ? 'left' : 'right',
                font: {
                    color: config.l[ii].yaxe.indexOf('Color') > -1 ? config.l[ii].color : (config.y_labels_color || 'black')
                },
                zoomRange: false,  // or [ number, number ] (min range, max range) or false
                panRange:  false,  // or [ number, number ] (min, max) or false
                // to do
                /*{
                    size: 11,
                    lineHeight: 13,
                    style: "italic",
                    weight: "bold",
                    family: "sans-serif",
                    variant: "small-caps",
                    color: "#545454"
                }*/
                //tickColor: 'red',

                tickFormatter: function (number, object) {
                    // If tickDecimals was specified, ensure that we have exactly that
                    // much precision; otherwise default to the value's own precision.

                    if (config.afterComma != null) {
                        var factor = config.afterComma ? Math.pow(10, config.afterComma) : 1;
                        var formatted = (Math.round(number * factor) / factor).toString();
                        var decimal = formatted.indexOf('.');
                        var precision = decimal == -1 ? 0 : formatted.length - decimal - 1;

                        if (precision < config.afterComma) {
                            number = (precision ? formatted : formatted + '.') + factor.toString().substr(1, config.afterComma - precision);
                        } else {
                            number = formatted;
                        }
                    }

                    if (config.useComma) number = number.toString().replace('.', ',');

                    var unit = config.l[object.n - 1].unit;

                    return number + (unit ? (' ' + unit) : '');
                }
            };

            var xaxi = {
                show:       config.l[ii].xaxe == 'off' ? false : true,
                position:   config.l[ii].xaxe.indexOf('top') !== -1 ? 'top' : 'bottom',
                font: {
                    color: config.l[ii].xaxe.indexOf('Color') !== -1 ? config.l[ii].color : (config.x_labels_color || 'black')
                },
                zoomRange: null,  // or [ number, number ] (min range, max range) or false
                panRange:  null,  // or [ number, number ] (min, max) or false
                mode:       'time',
                //timeformat: config.timeFormat,
                //timezone:   "browser",
                tickFormatter: config.timeFormat ? function (number, object) {
                    var now = new Date(parseInt(number, 10));
                    if (config.timeFormatDate && config.timeFormatTime) {
                        if (!object.ticks.length) {
                            return $.plot.formatDate(now, config.timeFormatDate);
                        }
                        var d = new Date(object.ticks[object.ticks.length - 1].v);
                        if (d.getDate() != now.getDate()) {
                            return $.plot.formatDate(now, config.timeFormatDate);
                        }
                        return $.plot.formatDate(now, config.timeFormatTime);
                    } else {
                        return $.plot.formatDate(now, config.timeFormat);
                    }
                    //return (new Date(object[0]))
                } : null,
                min: undefined,
                max: undefined
            };

            if (config.zoom) {
                xaxi.zoomRange = [null, now]; // or [ number, number] (min range, max range) or false
                xaxi.panRange  = [null, now]; // or [ number, number] (min range, max range) or false
            }

            settings.yaxes.push(yaxi);
            settings.xaxes.push(xaxi);
//            settings.yaxis["y"+(ii +1)] = axi

            // Support for commonYAxis
            if (config.l[ii].commonYAxis !== '') {
                series[ii].yaxis = parseInt(config.l[ii].commonYAxis);
            } else {
                series[ii].yaxis = ii + 1;
            }
            series[ii].xaxis = ii + 1;
        }

        if (config.smoothing) {
            settings.series = {
                curvedLines: {
                    apply:          true,
                    active:         true,
                    monotonicFit:   true
                }
            };
        }

        graph = $.plot('#chart_placeholder', series, settings);

        // Hoover
        if (config.hoverDetail === 'true' || config.hoverDetail === true) {
            $('#chart_placeholder').unbind('plothover').bind('plothover', function (event, pos, item) {
                if (item) {
                    var x = item.datapoint[0].toFixed(2);
                    var y;

                    if (config.l[item.seriesIndex].type === 'boolean') {
                        y = !!Math.round(item.datapoint[1] - config.l[item.seriesIndex].yOffset);
                    } else {
                        y = (item.datapoint[1] - config.l[item.seriesIndex].yOffset).toFixed(2)
                    }

                    var text = item.series.label ? item.series.label + '<br>' : '';
                    text += $.plot.formatDate(new Date(parseInt(x, 10)), config.timeFormat) + '<br>';
                    text += '<b>' + yFormatter(y) + '</b>';

                    var $tooltip = $('#tooltip').html(text);
                    if ($(this).height() - item.pageY < $tooltip.height()) {
                        item.pageY -= 10 + $tooltip.height();
                    }
                    if ($(this).width() - item.pageX < $tooltip.width()) {
                        item.pageX -= 10 + $tooltip.width();
                    }
                    $tooltip.css({top: item.pageY + 5, left: item.pageX + 5}).fadeIn(200);
                } else {
                    $('#tooltip').hide();
                }
            });

            if (!$('#tooltip').length) {
                $('<div id="tooltip"></div>').css({
                    position:   'absolute',
                    display:    'none',
                    border:     '1px solid #fdd',
                    padding:    '2px',
                    'background-color': '#fee',
                    opacity:    0.80
                }).appendTo('body');
            }
        }

        if (config.live && config.timeArt == 'relative') live();

        if (config.zoom) {
            // handlers for zoom and pan
            $('#chart_placeholder').unbind('plotzoom').bind('plotzoom', function (e, plot, args) {
                if (zoomTimeout) clearTimeout(zoomTimeout);
                zoomTimeout = setTimeout(onZoom, 500);
            }).unbind('plotpan').bind('plotpan', function (e, plot, args) {
                if (zoomTimeout) clearTimeout(zoomTimeout);
                zoomTimeout = setTimeout(onZoom, 500);
            });
        }
    }

    function updateLive() {
        var ready = 0;
        now = new Date();

        // actually not used
        /*function getData(index) {
            var option    = getStartStop(index, config.longestStep);
            var totalTime = getStartStop(index);
            option.instance    = config.l[index].instance;
            totalTime.instance = config.l[index].instance;

            ready++;
            console.log(JSON.stringify(option));

            // actual work around, while live Update does not work
            socket.emit('getHistory', config.l[index].id, option, function (err, res, step) {
                if (!err && res && series[index] && res[0]) {
                    totalTime.start         = totalTime.start * 1000;
                    totalTime.end           = totalTime.end   * 1000;
                    totalTime.ignoreNull    = (config.l[index].ignoreNull === undefined) ? (config.ignoreNull === 'true' || config.ignoreNull === true) : (config.l[index].ignoreNull === 'true' || config.l[index].ignoreNull === true);
                    totalTime.yOffset       = parseFloat(config.l[index].yOffset) || 0;

                    // actual work around, while live Update does not work
                    //series[index].data = [];

                    var data = series[index].data;
                    // remove all nulls at the end
                    while (data.length && data[data.length - 1][1] === null) {
                        data.pop();
                    }

                    var lastVal = null;
                    for (var i = 0; i < res.length; i++) {
                        // if less 2000.01.01 00:00:00
                        if (res[i].ts < 946681200000) res[i].ts = res[i].ts * 1000;

                        // remove all not requested points
                        if (res[i].ts < totalTime.start || res[i].ts > totalTime.end) continue;

                        // do not add existing values
                        if (data.length && data[data.length - 1][0] > res[i].ts) continue;

                        // Convert boolean values to numbers
                        if (res[i].val === 'true' || res[i].val === true) {
                            res[i].val = 1;
                        } else if (res[i].val === 'false' || res[i].val === false) {
                            res[i].val = 0;
                        }
                        if (typeof res[i].val == 'string') res[i].val = parseFloat(res[i].val);

                        if (res[i].val === null) {
                            if (totalTime.ignoreNull || i == res.length - 1) res[i].val = lastVal;
                        } else {
                            lastVal = res[i].val;
                        }

                        if (res[i].val !== null || i == res.length - 1) {
                            data.push([res[i].ts, res[i].val + totalTime.yOffset]);
                        }
                    }

                    // remove outaged starts
                    while (data.length && data[0][0] < totalTime.start) {
                        data.splice(0, 1);
                    }

                    // check stop
                    if (data[0][0]               > totalTime.start) data.unshift([totalTime.start, null]);
                    if (data[data.length - 1][0] < totalTime.end)   data.push([totalTime.end, null]);
                } else {
                    console.error('Error:' + err + ', Result:' + res + ', Series: ' + series[index] + ', Array: ' + res);
                }

                if (!--ready) {
//                    graph.draw();
                    graph = $.plot('#chart_placeholder', series, settings);
                }
            });
        }*/

        for (var index = 0; index < config.l.length; index++) {
            if (config.zoom) {
                settings.xaxes[index].zoomRange = [null, now];
                settings.xaxes[index].panRange  = [null, now];
            }
            ready++;
            seriesData[index] = [];
            readOneChart(config.l[index].id, config.l[index].instance, index, function () {
                if (!--ready) {
                    for (var _index = 0; _index < config.l.length; _index++) {
                        series[_index].data = seriesData[_index];
                    }
                    graph = $.plot('#chart_placeholder', series, settings);
                }
            });
        }
    }

    function live() {
        if (!config.longestStep) {
            console.warn('longestStep is zero!');
            config.longestStep = 300000;
        }
        if (config.longestStep < 1000) {
            config.longestStep = 1000;
        }
        liveInterval = setInterval(function () {
            if (config.zoomed) {
                var opt = graph.getOptions();
                var max = 0;
                var min = null;
                for (var index = 0; index < opt.xaxes.length; index++) {
                    if (max < config.l[index].zMax) max = config.l[index].zMax;
                    if (min === null || min > config.l[index].zMin) min = config.l[index].zMin;
                }
                // if 10%
                if (max + ((max - min) / 20) >= ((new Date().getTime() - config.longestStep)/ 1000)) {
                    max = Math.round((new Date().getTime() - now.getTime()) / 1000);
                    for (var index = 0; index < opt.xaxes.length; index++) {
                        config.l[index].zMax += max;
                        config.l[index].zMin += max;
                        settings.xaxes[index].min = config.l[index].zMin * 1000;
                        settings.xaxes[index].max = config.l[index].zMax * 1000;
                    }
                } else {
                    return;
                }
            }

            console.log('on time');
            updateLive();
        }, Math.round(config.longestStep));
    }
</script>

</body>
