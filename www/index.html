<head>
    <title>Flot Chart</title>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <link href="img/favicon.png" rel="shortcut icon" type="image/x-icon" />

    <link type="text/css" rel="stylesheet" href="/lib/css/themes/jquery-ui/redmond/jquery-ui.min.css">
    <!--link type="text/css" rel="stylesheet" href="lib/css/rickshaw.min.css"-->

    <script src="/lib/js/jquery-1.11.1.min.js"></script>
    <!--script src="/lib/js/jquery-ui.1.11.2.slider.min.js"></script-->
    <script src="/lib/js/socket.io.js"></script>

    <script src="lib/js/jquery.flot.min.js"></script>
    <script src="lib/js/jquery.flot.resize.min.js"></script>
    <script src="lib/js/jquery.flot.time.min.js"></script>
    <script src="lib/js/jquery.flot.categories.min.js"></script>
    <script src="lib/js/jquery.flot.pie.min.js"></script>
    <script src="lib/js/JUMFlot.min.js"></script>
    <script src="lib/js/curvedLines.js"></script>
    <script src="lib/js/jquery.flot.selection.min.js"></script>
    <script src="lib/js/jquery.flot.hiddengraphs.js"></script>
    <script src="lib/js/jquery-deparam.js"></script>
    <!--script src="lib/js/jquery.flot.navigate.min.js"></script-->
    <script src="/_socket/info.js"></script>
    <style>
        .rickshaw_graph .x_tick.invisible {
            border-left: 0 rgba(0, 0, 0, 0) !important;
        }

        #title {
            font-size: 24px;
            font-weight: bold;
        }

        div, span, p, td {
            font-family: Arial, sans-serif;
        }

        #chart {
            display: inline-block;
        }

        #legend_container {
            position: absolute;
            right: 0;
            bottom: 26px;
            width: 0;
        }

        .chart-container {
            box-sizing: border-box;
            padding: 20px 15px 15px 15px;
            /*margin: 15px auto 30px auto;*/
            border: 1px solid #ddd;
            background: #fff;
            background: linear-gradient(#f6f6f6 0, #fff 50px);
            background: -o-linear-gradient(#f6f6f6 0, #fff 50px);
            background: -ms-linear-gradient(#f6f6f6 0, #fff 50px);
            background: -moz-linear-gradient(#f6f6f6 0, #fff 50px);
            background: -webkit-linear-gradient(#f6f6f6 0, #fff 50px);
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.15);
            -o-box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1);
            -ms-box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1);
            -moz-box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1);
            -webkit-box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1);
        }

        .chart-placeholder {
            width: 100%;
            height: 100%;
            font-size: 14px;
            line-height: 1.2em;
        }

        .loader {
            display: none;
            position: absolute;
            left: calc(50% - 0.5em);
            top: calc(50% - 0.5em - 72px);
            font-size: 90px;
            text-indent: -9999em;
            overflow: hidden;
            width: 1em;
            height: 1em;
            border-radius: 50%;
            margin: 72px auto;
            -webkit-transform: translateZ(0);
            -ms-transform: translateZ(0);
            transform: translateZ(0);
            -webkit-animation: load6 1.7s infinite ease;
            animation: load6 1.7s infinite ease;
        }

        @-webkit-keyframes load6 {
            0% {
                -webkit-transform: rotate(0deg);
                transform: rotate(0deg);
                box-shadow: 0 -0.83em 0 -0.4em #00ffff, 0 -0.83em 0 -0.42em #00ffff, 0 -0.83em 0 -0.44em #00ffff, 0 -0.83em 0 -0.46em #00ffff, 0 -0.83em 0 -0.477em #00ffff;
            }
            5%,
            95% {
                box-shadow: 0 -0.83em 0 -0.4em #00ffff, 0 -0.83em 0 -0.42em #00ffff, 0 -0.83em 0 -0.44em #00ffff, 0 -0.83em 0 -0.46em #00ffff, 0 -0.83em 0 -0.477em #00ffff;
            }
            10%,
            59% {
                box-shadow: 0 -0.83em 0 -0.4em #00ffff, -0.087em -0.825em 0 -0.42em #00ffff, -0.173em -0.812em 0 -0.44em #00ffff, -0.256em -0.789em 0 -0.46em #00ffff, -0.297em -0.775em 0 -0.477em #00ffff;
            }
            20% {
                box-shadow: 0 -0.83em 0 -0.4em #00ffff, -0.338em -0.758em 0 -0.42em #00ffff, -0.555em -0.617em 0 -0.44em #00ffff, -0.671em -0.488em 0 -0.46em #00ffff, -0.749em -0.34em 0 -0.477em #00ffff;
            }
            38% {
                box-shadow: 0 -0.83em 0 -0.4em #00ffff, -0.377em -0.74em 0 -0.42em #00ffff, -0.645em -0.522em 0 -0.44em #00ffff, -0.775em -0.297em 0 -0.46em #00ffff, -0.82em -0.09em 0 -0.477em #00ffff;
            }
            100% {
                -webkit-transform: rotate(360deg);
                transform: rotate(360deg);
                box-shadow: 0 -0.83em 0 -0.4em #00ffff, 0 -0.83em 0 -0.42em #00ffff, 0 -0.83em 0 -0.44em #00ffff, 0 -0.83em 0 -0.46em #00ffff, 0 -0.83em 0 -0.477em #00ffff;
            }
        }

        @keyframes load6 {
            0% {
                -webkit-transform: rotate(0deg);
                transform: rotate(0deg);
                box-shadow: 0 -0.83em 0 -0.4em #00ffff, 0 -0.83em 0 -0.42em #00ffff, 0 -0.83em 0 -0.44em #00ffff, 0 -0.83em 0 -0.46em #00ffff, 0 -0.83em 0 -0.477em #00ffff;
            }
            5%,
            95% {
                box-shadow: 0 -0.83em 0 -0.4em #00ffff, 0 -0.83em 0 -0.42em #00ffff, 0 -0.83em 0 -0.44em #00ffff, 0 -0.83em 0 -0.46em #00ffff, 0 -0.83em 0 -0.477em #00ffff;
            }
            10%,
            59% {
                box-shadow: 0 -0.83em 0 -0.4em #00ffff, -0.087em -0.825em 0 -0.42em #00ffff, -0.173em -0.812em 0 -0.44em #00ffff, -0.256em -0.789em 0 -0.46em #00ffff, -0.297em -0.775em 0 -0.477em #00ffff;
            }
            20% {
                box-shadow: 0 -0.83em 0 -0.4em #00ffff, -0.338em -0.758em 0 -0.42em #00ffff, -0.555em -0.617em 0 -0.44em #00ffff, -0.671em -0.488em 0 -0.46em #00ffff, -0.749em -0.34em 0 -0.477em #00ffff;
            }
            38% {
                box-shadow: 0 -0.83em 0 -0.4em #00ffff, -0.377em -0.74em 0 -0.42em #00ffff, -0.645em -0.522em 0 -0.44em #00ffff, -0.775em -0.297em 0 -0.46em #00ffff, -0.82em -0.09em 0 -0.477em #00ffff;
            }
            100% {
                -webkit-transform: rotate(360deg);
                transform: rotate(360deg);
                box-shadow: 0 -0.83em 0 -0.4em #00ffff, 0 -0.83em 0 -0.42em #00ffff, 0 -0.83em 0 -0.44em #00ffff, 0 -0.83em 0 -0.46em #00ffff, 0 -0.83em 0 -0.477em #00ffff;
            }
        }

    </style>
</head>
<body>

<div id="chart_container">
    <div id="loader" class="loader"></div>
    <div id="no-connection"
         style="position:absolute; left:50%; top: 50%; display:none; font-size: 3em; background: rgba(0,0,0,0.1); border-radius: 10px; text-align: center">
        No connection to server
    </div>
    <div id="chart_placeholder" class="chart-placeholder"></div>
    <div id="title" style="position:absolute"></div>
</div>
<!--<div id="nav-bar" style="position: relative">-->
    <!--<button id="navLeft"  style="position: absolute; right:50px">right</button>-->
    <!--<button id="navNow"  onclick="NavNow()" style="position: absolute; right:50%">now</button>-->
    <!--<button id="navRight" style="position: absolute; left:50px">left</button>-->
<!--</div>-->
<script>
    var graph;

    var backgrounds = [
        ['#8e9eab', '#eef2f3'], //Portrait
        ['#517fa4', '#243949'], //Instagram
        ['#485563', '#29323c'], //ServQuick
        ['#abbaab', '#00ffff'], //Metallic Toad
        ['#ECE9E6', '#00ffff'], //Clouds
        ['#16222A', '#3A6073'], //Mirage
        ['#1F1C2C', '#928DAB'], //Steel Gray
        ['#003973', '#E5E5BE'], //Horizon
        ['#D1913C', '#FFD194'], //Koko Caramel
        ['#136a8a', '#267871']  //Turquoise flow
    ];

    // Show "no connection" message after 5 seconds
    var disconnectTimeout = setTimeout(function () {
        disconnectTimeout = null;
        //Show disconnected message
        $('#no-connection').show();
    }, 5000);

    var timeout = null;

    // Analyse query
    var path = location.href.split('?')[1];

    // convert old format to new one
    // OLD: http://localhost:8082/flot/index.html?range=1440&renderer=line&axeX=lines&axeY=inside&_ids=system.adapter.admin.0.memRss%2Csystem.adapter.email.0.memRss&_colors=%23c05020%3B%2330c020%3B%236060c0
    // NEW: http://localhost:8082/flot/index.html?lines%5B0%5D%5Bid%5D=system.adapter.admin.0.memRss&lines%5B0%5D%5Boffset%5D=0&lines%5B0%5D%5Bart%5D=average&lines%5B0%5D%5Bcolor%5D=%23FF0000&lines%5B0%5D%5Bthickness%5D=3&lines%5B1%5D%5Bid%5D=system.adapter.email.0.memRss&lines%5B1%5D%5Boffset%5D=0&lines%5B1%5D%5Bart%5D=average&lines%5B1%5D%5Bcolor%5D=%2300FF00&lines%5B1%5D%5Bthickness%5D=3&timeArt=relative&relativeEnd=now&range=10&aggregateType=step&aggregateSpan=300&legend=sw
    // OLD =>
    //{
    //    _colors: "#c05020;#30c020;#6060c0"
    //    _ids: "system.adapter.admin.0.memRss,system.adapter.email.0.memRss"
    //    axeX: "lines"
    //    axeY: "inside"
    //    range: "1440"
    //    renderer: "line"
    //}
    // NEW =>
    //{
    //  "lines" : [
    //     {
    //        "id" : "system.adapter.admin.0.memRss",
    //        "offset" : "0",
    //        "art" : "average",
    //        "color" : "#FF0000",
    //        "thickness" : "3"
    //      }, {
    //        "id" : "system.adapter.email.0.memRss",
    //        "offset" : "0",
    //        "art" : "average",
    //        "color" : "#00FF00",
    //        "thickness" : "3"
    //      }
    //  ],
    //    "timeArt" : "relative",
    //    "relativeEnd" : "now",
    //    "range" : "10",
    //    "aggregateType" : "step",
    //    "aggregateSpan" : "300",
    //    "legend" : "sw    //}

    var config = deparam(path || '');

    if (config._ids) {
        var ids    = config._ids    ? config._ids.split(';')    : [];
        var colors = config._colors ? config._colors.split(';') : [];
        var names  = config._names  ? config._names.split(';')  : [];
        var units  = config._units  ? config._units.split(';')  : [];
        config.lines = [];
        for (var i = 0; i < ids.length; i++) {
            config.lines.push({
                id:         ids[i],
                offset:     0,
                name:       names[i] || '',
                art:        "average",
                color:      colors[i] || 'blue',
                thickness:  config.strokeWidth || 1,
                shadowsize: config.strokeWidth || 1,
                min:        config.min || '',
                max:        config.max || '',
                unit:       units[i]   || ''
            });
        }
        config.range = parseInt(config.range, 10);
        config.aggregateType = "step";
        config.aggregateSpan = 300;
        config.relativeEnd   = "now";
    }

    // Set default values
    config.longestStep = 0;
    config.width        = config.width || '100%';
    config.height       = config.height || '100%';
    config.timeFormat   = config.timeFormat || "%H:%M:%S %e.%m.%y";
    config.useComma     = config.useComma === 'true';
    config.afterComma   = (config.afterComma === undefined) ? 2 : config.afterComma;
    //    if ((config.max !== undefined && config.max != '' && parseFloat(config.max) != NaN)) config.max = parseFloat(config.max);
    var seriesData      = [];
    var series          = [];
    var settings        = [];
    var from;
    var to;

    var stepLeftCount   = 0;
    var stepRightCount  = 0;

    var liveInterval;

    var navStep         = config.navStepMulti == "w" ? undefined : parseInt((config.navStep || 1) * (config.navStepMulti || 1));

    var navStepMulti    = 0;
    var navOptions      = {};
    var navLeft;
    var navRight;

    //var socket = io.connect();
    var socketURL       = '';
    var socketSESSION   = '';
    
    if (typeof socketUrl != 'undefined') {
        socketURL = socketUrl;
        if (socketURL && socketURL[0] == ':') {
            socketURL = 'http://' + location.hostname + socketURL;
        }
        socketSESSION = socketSession;
    }

    var socket = io.connect(socketURL, {
        'query': 'key=' + socketSESSION,
        'reconnection limit': 10000,
        'max reconnection attempts': Infinity
    });

    //socket.on('stateChange', function (changeId, state) {
    //    if (graph && config && config._ids ) {
    //        for (j = 0; j < config._ids.length; j++) {
    //            if (config._ids[j] == changeId) {
    //                if (config.renderer == 'pie') {
    //                    seriesData[0][j].data = state.val;
    //                    graph.setData(seriesData[0]);
    //                    graph.draw();
    //                } else if (config.renderer == 'bar' && config._ids.length > 1) {
    //                    seriesData[0][j][1] = state.val;
    //                    graph.setData(seriesData);
    //                    graph.setupGrid();
    //                    graph.draw();
    //                } else {
    //                    var ticks = state.ts * 1000;
    //                    seriesData[j].push([ticks, state.val]);
    //                    var d = new Date(ticks);
    //
    //                    // Calculate tick in the past
    //                    d.setMinutes(d.getMinutes() - config.range);
    //                    ticks = d.getTime();
    //
    //                    // Find last tick that is older than range
    //                    for (var i = 0; i < seriesData[j].length; i++) {
    //                        if (seriesData[j][i][0] > ticks) break;
    //                    }
    //
    //                    if (i) seriesData[j].splice(0, i);
    //
    //                    seriesData[j] = fillRange(seriesData[j]);
    //
    //                    /*graph.setData(seriesData);
    //                     graph.setupGrid();
    //                     graph.draw();*/
    //                    buildGraph(from, to);
    //                }
    //                break;
    //            }
    //        }
    //    }
    //});

    socket.on('connect', function () {
        socket.emit('name', 'flot');
        if (disconnectTimeout) {
            $('#no-connection').hide();
            clearTimeout(disconnectTimeout);
            disconnectTimeout = null;
        }
        readData();
    });

    socket.on('disconnect', function () {
        if (!disconnectTimeout) {
            disconnectTimeout = setTimeout(function () {
                disconnectTimeout = null;
                //Show disconnected message
                $('#no-connection').show();
            }, 5000);
        }
    });
    /*
     function fillRange(data) {
     // Add first tick with required range
     if (config.fillRange) {
     var now = new Date();
     var start = new Date(now);
     start.setMinutes(start.getMinutes() - config.range + 1);

     if (data.length) {
     if (data[0][0] > start.getTime()) {
     data.unshift([start.getTime(), null]);
     }
     if (data[data.length - 1][0] < now.getTime()) {
     data.push([now.getTime(), data[data.length - 1][1]]);
     }
     } else {
     data.push([start.getTime(), null]);
     data.push([now.getTime(), null]);
     }
     }

     // first of all sort data
     data.sort(function (a, b) {
     return a[0] - b[0];
     });

     // find smallest interval
     var step = null;
     var s;
     var i;
     var isDifferent = false;
     for (i = 1; i < data.length; i++) {
     s = data[i][0] - data[i - 1][0];
     if (step === null) {
     step = s;
     } else if (s < step) {
     step = s;
     }
     if (step != s) {
     isDifferent = true;
     }
     }

     if (!isDifferent || !config.interpolation) return data;

     var result = [];
     var time = data[0][0];
     var end = data[data.length - 1][0];
     i = 0;

     var tDiff = data[1][0] - data[0][0];
     var vDiff = data[1][1] - data[0][1];
     var tVal = data[0][0];
     var vVal = data[0][1];
     var tEnd = data[1][0];
     // interpolation
     while (time <= end) {
     while (tEnd <= time && i < data.length - 1) {
     i++;
     tVal = data[i][0];
     vVal = data[i][1];
     if (vVal !== null) {
     if (i + 1 < data.length) {
     tEnd = data[i + 1][0];
     tDiff = tEnd - data[i][0];
     if (data[i + 1][1] === null) {
     vDiff = 0;
     } else {
     vDiff = data[i + 1][1] - data[i][1];
     }
     } else {
     tEnd = end;
     tDiff = end - data[i][1];
     vDiff = 0;
     }
     } else if (i + 1 < data.length) {
     tEnd = data[i + 1][0];
     } else {
     tEnd = end;
     }
     }
     result.push([time, vVal === null ? null : vVal + (time - tVal) * vDiff / tDiff]);
     time += step;
     }

     return result;
     }*/

    function getStartStop(index, step) {
        var option = {};
        var end;
        var start;

        if (!step) {

            if (config.timeArt == 'static') {
                if (config.start_time != undefined) {
                    var start_time = config.start_time.split(':').map(Number);
                } else {
                    var start_time = [0,0];
                }

                if (config.end_time != undefined) {
                    var end_time = config.end_time.split(':').map(Number);
                } else {
                    var end_time = [24,0];
                }

                start = Math.round(new Date(config.start).setHours(start_time[0],start_time[1]) / 1000) - (config.lines[index].offset || 0);
                end = Math.round(new Date(config.end).setHours(end_time[0],end_time[1]) / 1000) - (config.lines[index].offset || 0);

            } else {
                if (config.relativeEnd == 'now') {
                    end = Math.round(new Date() / 1000) - (config.lines[index].offset || 0);
                    start = end - (config.range * 60);
                } else if (config.relativeEnd == 'today') {
                    end = Math.round(new Date().setHours(24) / 1000) - (config.lines[index].offset || 0);
                    start = Math.round(new Date(new Date(new Date().setHours(24)).setMinutes(0)).setSeconds(0) / 1000) - (config.range * 60) - (config.lines[index].offset || 0);
                }
            }

            option = {
                start: start,
                end: end,
                ignoreNull: config.getNull || false,
                aggregate: config.lines[index].art || 'average'
            };


            if (config.aggregateType == 'step') {
                option.step = config.aggregateSpan;
            } else if (config.aggregateType == 'count') {
                option.count = config.aggregateSpan || document.getElementById("chart_container").clientWidth;
            }

            navOptions[index] = option;
            return option

        } else {

            end = Math.round(new Date() / 1000) - (config.lines[index].offset || 0);
            start = end - (step);

            option = {
                start: start,
                end: end,
                ignoreNull: config.getNull || false,
                aggregate: config.lines[index].art || 'average',
                count: 1
            };

            navOptions[index].end = end;
            navOptions[index].start = end - (config.range * 60);
            return option;
        }
    }

    function getStartStopNav(index) {

        var option = {
            start: navOptions[index].start - (navStep * navStepMulti),
            end: navOptions[index].end - (navStep * navStepMulti),
            ignoreNull: config.getNull || false,
            aggregate: config.lines[index].art || 'average',
        };

        if (config.aggregateType == 'step') {
            option.step = config.aggregateSpan;
        } else if (config.aggregateType == 'count') {
            option.count = config.aggregateSpan || document.getElementById("chart_container").clientWidth;
        }

        return option;

    }

    function readOneChart(id, instance, index, callback) {

        var option = getStartStop(index);
        option.instance = instance;

        socket.emit('getHistory', id, option, function (err, res, step) {
            if (!err && res) {
                //for (var i = 0, len = res.length; i < len; i++) {

                if (config.longestStep < step) {
                    config.longestStep = step;
                }
                for (var i = 0; i < res.length; i++) {
                    if (res[i].val != null || !config.ignoreNull) {

                        // Convert boolean values to numbers
                        if (res[i].val === 'true' || res[i].val === true) {
                            res[i].val = 1;
                        } else if (res[i].val === 'false' || res[i].val === false) {
                            res[i].val = 0;
                        }
                        if (typeof res[i].val == 'string') res[i].val = parseFloat(res[i].val);


                        seriesData[index].push([res[i].ts * 1000, res[i].val]);
                    }

                }
            }

            // Add first tick with required range
            // todo muss das sein ??
            //seriesData[index] = fillRange(seriesData[index]);

            if (callback) callback(id, index);
        });
    }

    function yFormatter(y) {
        if (config.afterComma !== undefined && config.afterComma !== null) {
            y = parseFloat(y);
            if (config.useComma) {
                return y.toFixed(config.afterComma).toString().replace('.', ',');
            } else {
                return y.toFixed(config.afterComma);
            }
        } else {
            if (config.useComma) {
                y = parseFloat(y);
                return y.toString().replace('.', ',');
            } else {
                return y;
            }
        }
    }

    function readOneValue(id, index, callback) {
        socket.emit('getObject', id, function (err, res) {
            if (!err && res && res.common) {
                config.lines[index].name = config.lines[index].name || res.common.name;
                config.lines[index].unit = config.lines[index].unit || (res.common.unit ? res.common.unit.replace('�', '°') : '');
            } else {
                config.lines[index].name = config.lines[index].name || id;
                config.lines[index].unit = config.lines[index].unit || '';
            }

            socket.emit('getState', id, function (err, state) {
                if (state) {
                    callback(id, index, state.val);
                } else {
                    callback(id, index, null)
                }
            });
        });
    }

    function readData(hidden) {
        if (disconnectTimeout) {
            $('#no-connection').hide();
            clearTimeout(disconnectTimeout);
            disconnectTimeout = null;
        }

        if (config.lines) {
            if (!hidden) {
                $('#loader').show();
            }

            // todo
//            if (config.renderer == 'pie' || (config.renderer == 'bar' && config._ids.length > 1)) {
//
//                seriesData = [[]];
//                for (var j = 0; j < config._ids.length; j++) {
//                    readOneValue(config._ids[j], j, function (_id, _index, value) {
//                        if (config.renderer == 'pie') {
//                            seriesData[0][_index] = {label: config.line[_index].name, data: value};
//                        } else {
//                            seriesData[0][_index] = [config.line[_index].name, value];
//                        }
//                        if (_index == config._ids.length - 1) {
//                            buildGraph();
//                        }
//                    });
//                }
//            } else {
            for (var j = 0; j < config.lines.length; j++) {
                if (config.lines[j] !== '' && config.lines[j] !== undefined) {
                    seriesData.push([]);
                }
            }
            var ready = 0;
            for (j = 0; j < config.lines.length; j++) {


                function read(index) {
                    socket.emit('getObject', config.lines[index].id, function (err, res) {
                        if (!err && res && res.common) {
                            config.lines[index].name = config.lines[index].name || res.common.name;
                            config.lines[index].unit = config.lines[index].unit || (res.common.unit ? res.common.unit.replace('�', '°') : '');
                        } else {
                            config.lines[index].name = config.lines[index].name || id;
                            config.lines[index].unit = config.lines[index].unit || '';
                        }
                        readOneChart(config.lines[index].id, config.lines[index].instance, index, function () {
                            ready++;
                            if (ready == config.lines.length) {
                                $('#loader').hide();
                                buildGraph();
                            }
                        });
                    });
                }

                read(j)
            }
//            }
        }
    }

    function buildGraph() {
        series = [];
        var $title = $('#title');

        if (config.title && !$title.html()) {
            $title.html(decodeURI(config.title));
            if (config.titleColor) $title.css('color', config.titleColor);
            if (config.titleSize) $title.css('font-size', config.titleSize);
            if (config.titlePos) {
                var parts = config.titlePos.split(';');
                var css = {};
                for (var t = 0; t < parts.length; t++) {
                    var p = parts[t].split(':');

                    // Bottom inside
                    if (p[0] == 'bottom' && p[1] == '5') {
                        if (config.height.indexOf('%') == -1) {
                            css.top = parseInt(config.height, 10) - $title.height() - 45;
                        } else {
                            css.top = 'calc(' + config.height + ' - ' + ($title.height() + 45) + 'px)';
                        }
                    } else	// Bottom outside
                    if (p[0] == 'bottom' && p[1] == '-5') {
                        if (config.height.indexOf('%') == -1) {
                            css.top = parseInt(config.height, 10) + 5;
                        } else {
                            css.top = 'calc(' + config.height + ' + 5px)';
                        }
                    } else	// Middle
                    if (p[0] == 'top' && p[1] == '50') {
                        if (config.height.indexOf('%') == -1) {
                            css.top = (parseInt(config.height, 10) - $title.height()) / 2;
                        } else {
                            css.top = 'calc(50% - ' + ($title.height() / 2) + 'px)';
                        }
                    } else	// Center
                    if (p[0] == 'left' && p[1] == '50') {
                        if (config.width.indexOf('%') == -1) {
                            css.left = (parseInt(config.width, 10) - $title.width()) / 2;
                        } else {
                            css.left = 'calc(50% - ' + ($title.width() / 2) + 'px)';
                        }
                    } else	// Right inside
                    if (p[0] == 'right' && p[1] == '5') {
                        if (config.width.indexOf('%') == -1) {
                            css.left = parseInt(config.width, 10) - $title.width() - 45;
                        } else {
                            css.left = 'calc(' + config.width + ' - ' + ($title.width() + 45) + 'px)';
                        }
                    } else	// Right outside
                    if (p[0] == 'right' && p[1] == '-5') {
                        if (config.width.indexOf('%') == -1) {
                            css.left = parseInt(config.width, 10) + 25;
                        } else {
                            css.left = 'calc(' + config.width + ' + 5px)';
                        }
                    } else {
                        css[p[0]] = p[1];
                    }
                }

                $title.css(css);
            }
        }


        // Replace background
        if (config.bg && config.bg.length < 3 && backgrounds[config.bg]) config.bg = {colors: backgrounds[config.bg]};

        //todo make bar working
//        if (config.renderer != 'bar' || config._ids.length <= 1) {


        for (var i = 0; i < seriesData.length; i++) {
            if (seriesData[i]) {

                config.lines[i].chartType = config.lines[i].chartType || 'line';

                var option = {
                    color: config.lines[i].color || undefined,
                    lines: {
                        show: (config.lines[i].chartType != 'scatterplot' && config.lines[i].chartType != 'bar'),
                        fill: (config.lines[i].chartType == 'area' || config.lines[i].chartType == 'bar'),
                        steps: (config.lines[i].chartType == 'steps'),
                        lineWidth: config.lines[i].thickness
                    },
                    bars: {
                        show: (config.lines[i].chartType == 'bar'),
                        barWidth: 0.6
                    },
                    points: {
                        show: (config.lines[i].chartType == 'lineplot' || config.lines[i].chartType == 'scatterplot')
                    },
                    data: seriesData[i],
                    label: config.lines[i].name,
                    shadowSize: config.lines[i].shadowsize
                };

                if (config.smoothing > 0) {
                    config.smoothing = parseInt(config.smoothing);

                    if (config.smoothing > 1) {
                        option.data = $.plot.JUMlib.prepareData.avg(option.data, config.smoothing);
                    }
                    option.data = $.plot.JUMlib.prepareData.avg(option.data, config.smoothing);
                } else {
                    config.smoothing = 0;
                }
                if (config.lines[i].chartType == 'bar') {
                    option.bars.barWidth = (option.data[option.data.length - 1][0] - option.data[0][0]) / option.data.length * 0.5;
                }

                series.push(option);
            }
        }
//        }

        if (config.min === null || config.min === undefined || config.min === '' || config.min.toString() === 'NaN') {
            config.min = undefined;
        } else {
            config.min = parseFloat(config.min);
        }

        if (config.noBorder) {
            if (!config.width)  config.width = '100%';
            if (!config.height) config.height = '100%';

            if (config.width.indexOf('%') != -1) {
                $('#chart_container').css({width: 'calc(' + config.width + ' - 20px)'}); // original 20px
            } else {
                $('#chart_container').css({width: config.width});
            }
            if (config.height.indexOf('%') != -1) {
                $('#chart_container').css({height: 'calc(' + config.height + ' - 20px)'});// original 20px
            } else {
                $('#chart_container').css({height: config.height});
            }

        } else {
            $('#chart_container').addClass('chart-container').css({width: config.width, height: config.height});
//            $('#chart_container').css({'padding-bottom':"100px"})
        }

        if (config.timeFormat === 'null') config.timeFormat = undefined;

        if (config.timeFormat) {
            if (config.timeFormat.indexOf('%H:%M:%S') != -1) {
                config.timeFormatTime = '%H:%M:%S';
            } else if (config.timeFormat.indexOf('%I:%M:%S') != -1) {
                config.timeFormatTime = '%I:%M:%S';
            } else if (config.timeFormat.indexOf('%H:%M') != -1) {
                config.timeFormatTime = '%H:%M';
            } else {
                config.timeFormatTime = null;
            }
            if (config.timeFormat.indexOf('%d.%m.%y') != -1) {
                config.timeFormatDate = '%d.%m.%y';
            } else if (config.timeFormat.indexOf('%x %p') != -1) {
                config.timeFormatDate = '%x %p';
            } else if (config.timeFormat.indexOf('%d/%m/%y') != -1) {
                config.timeFormatDate = '%d/%m/%y';
            } else if (config.timeFormat.indexOf('%m.%d.%y') != -1) {
                config.timeFormatDate = '%m.%d.%y';
            } else if (config.timeFormat.indexOf('%d.%m') != -1) {
                config.timeFormatDate = '%d.%m';
            } else {
                config.timeFormatDate = null;
            }
        }

//        if (config.lines[i].chartType == 'pie') {
//            series.legend = {
//                show: !!config.legend,
//                position: config.legend
//            };
//            graph = $.plot("#chart_placeholder", seriesData[0], series);
//        } else if (config.lines[i].chartType == 'bar' && config._ids.length > 1) {
//            var series = {
//                series: {
//                    bars: {
//                        show: config.lines[i].chartType == 'bar',
//                        barWidth: 0.6,
//                        align: "center"
//                    },
//                    pie: {
//                        show: config.lines[i].chartType == 'pie'
//                    },
//                    legend: {
//                        show: !!config.legend,
//                        position: config.legend
//                    }
//                }
//            };
//
//            series.xaxis = {
//                mode: "categories",
//                tickLength: 0
//            };
//
//            graph = $.plot("#chart_placeholder", [seriesData[0]], series);
//        } else {

        settings = {
            grid: {
                hoverable: (config.hoverDetail === 'true' || config.hoverDetail === true),
                backgroundColor: config.bg || undefined
            },
            yaxes: [],
            xaxes: [],
            legend: {
                show: !!config.legend,
                position: config.legend,
                hideable: true
            }
        };

        for (var ii = 0; ii < config.lines.length; ii++) {

            config.lines[ii].yaxe = config.lines[ii].yaxe || '';
            config.lines[ii].xaxe = config.lines[ii].xaxe || '';
            config.lines[ii].commonYAxis = config.lines[ii].commonYAxis || '';

            var yaxi = {
                show: config.lines[ii].yaxe == 'off' ? false : true,
                min: config.lines[ii].min,
                max: config.lines[ii].max,
                position: config.lines[ii].yaxe.indexOf('left') > -1 ? 'left' : 'right',
                font: {
                    color: config.lines[ii].yaxe.indexOf('Color') > -1 ? config.lines[ii].color : 'black'
                },
                tickFormatter: function (number, object) {
                    // If tickDecimals was specified, ensure that we have exactly that
                    // much precision; otherwise default to the value's own precision.

                    if (config.afterComma != null) {
                        var factor = config.afterComma ? Math.pow(10, config.afterComma) : 1;
                        var formatted = (Math.round(number * factor) / factor).toString();
                        var decimal = formatted.indexOf('.');
                        var precision = decimal == -1 ? 0 : formatted.length - decimal - 1;

                        if (precision < config.afterComma) {
                            number = (precision ? formatted : formatted + '.') + factor.toString().substr(1, config.afterComma - precision);
                        } else {
                            number = formatted;
                        }
                    }
                    if (config.useComma) {
                        number = number.toString().replace('.', ',');
                    }

                    var unit = config.lines[object.n - 1].unit;

                    return number + (unit ? (' ' + unit) : '');
                }
            };

            var xaxi = {
                show: config.lines[ii].xaxe == 'off' ? false : true,
                position: config.lines[ii].xaxe.indexOf("top") > -1 ? 'top' : 'bottom',
                font: {
                    color: config.lines[ii].xaxe.indexOf('Color') > -1 ? config.lines[ii].color : 'black'
                },
                mode: 'time',
                //timeformat: config.timeFormat,
                //timezone:   "browser",
                tickFormatter: config.timeFormat ? function (number, object) {
                    var now = new Date(parseInt(number, 10));
                    if (config.timeFormatDate && config.timeFormatTime) {
                        if (!object.ticks.length) {
                            return $.plot.formatDate(now, config.timeFormatDate);
                        }
                        var d = new Date(object.ticks[object.ticks.length - 1].v);
                        if (d.getDate() != now.getDate()) {
                            return $.plot.formatDate(now, config.timeFormatDate);
                        }
                        return $.plot.formatDate(now, config.timeFormatTime);
                    } else {
                        return $.plot.formatDate(now, config.timeFormat);
                    }
                    //return (new Date(object[0]))
                } : null,
                min: from   || undefined,
                max: to     || undefined
            };

            settings.yaxes.push(yaxi);
            settings.xaxes.push(xaxi);
//            settings.yaxis["y"+(ii +1)] = axi

// Support for commonYAxis
            if (config.lines[ii].commonYAxis !== '') {
                series[ii].yaxis = parseInt(config.lines[ii].commonYAxis);
            }
            else {
                series[ii].yaxis = ii + 1;
            }
            series[ii].xaxis = ii + 1;
        }

        if (config.smoothing) {
            settings.series = {
                curvedLines: {
                    apply: true,
                    active: true,
                    monotonicFit: true
                }
            };
        }


        graph = $.plot('#chart_placeholder', series, settings);

        // Hoover
        if (config.hoverDetail === 'true' || config.hoverDetail === true) {
            $('#chart_placeholder').unbind('plothover').bind('plothover', function (event, pos, item) {
                if (item) {
                    var x = item.datapoint[0].toFixed(2);
                    var y = item.datapoint[1].toFixed(2);

                    var text = item.series.label ? item.series.label + '<br>' : '';
                    text += $.plot.formatDate(new Date(parseInt(x, 10)), config.timeFormat) + '<br>';
                    text += '<b>' + yFormatter(y) + '</b>';

                    var $tooltip = $('#tooltip').html(text);
                    if ($(this).height() - item.pageY < $tooltip.height()) {
                        item.pageY -= 10 + $tooltip.height();
                    }
                    if ($(this).width() - item.pageX < $tooltip.width()) {
                        item.pageX -= 10 + $tooltip.width();
                    }
                    $tooltip.css({top: item.pageY + 5, left: item.pageX + 5}).fadeIn(200);
                } else {
                    $('#tooltip').hide();
                }
            });

            if (!$('#tooltip').length) {
                $('<div id="tooltip"></div>').css({
                    position: 'absolute',
                    display: 'none',
                    border: '1px solid #fdd',
                    padding: '2px',
                    "background-color": '#fee',
                    opacity: 0.80
                }).appendTo('body');
            }
        }

        if (config.live && config.timeArt == 'relative') {
            live()
        }
    }

    function updateLive() {
        var ready = 0;

        function getData(index) {
            var option = getStartStop(j, config.longestStep);
            option.instance = config.lines[index].instance;
  
            socket.emit('getHistory', config.lines[index].id, option, function (err, res, step) {
                if (!err && res && series[index] && res[0]) {
                    series[index].data.shift();
                    if (res[0].val == null){
                        res[0].val = series[index].data[series[index].data.length - 1][1];
                    }
                    series[index].data.push([res[0].ts * 1000, res[0].val]);
                } else {
                    console.error('Error:' + err + ', Result:' + res + ', Series: ' + series[index] + ', Array: ' + res);
                }

                ready++;
                if (ready == config.lines.length) {

//                    graph.draw();
                    graph = $.plot('#chart_placeholder', series, settings);
                }
            });
        }

        for (var j = 0; j < config.lines.length; j++) {
            getData(j);
        }
    }

    function updateNav() {
        var ready = 0;


        function read(index, callback) {
            var option = getStartStopNav(index);
            option.instance = config.lines[index].instance;

            socket.emit('getHistory', config.lines[index].id, option, function (err, res, step) {
                if (!err && res) {
                    //for (var i = 0, len = res.length; i < len; i++) {
                    series[index].data = [];

                    for (var i = 0; i < res.length; i++) {
                        if (res[i].val != null || !config.ignoreNull) {

                            // Convert boolean values to numbers
                            if (res[i].val === 'true' || res[i].val === true) {
                                res[i].val = 1;
                            } else if (res[i].val === 'false' || res[i].val === false) {
                                res[i].val = 0;
                            }
                            if (typeof res[i].val == 'string') res[i].val = parseFloat(res[i].val);


                            series[index].data.push([res[i].ts * 1000, res[i].val]);
                        }

                    }

                }

                // Add first tick with required range
                // todo muss das sein ??
                //seriesData[index] = fillRange(seriesData[index]);
                callback();
            });
        }

        for (var j = 0; j < config.lines.length; j++) {
            read(j, function () {
                ready++;
                if (ready == config.lines.length) {
//                    graph.setData(series);
//                    graph.draw();
                    graph = $.plot('#chart_placeholder', series, settings);

//                    if(navLeft){
//                        navStepLeft()
//                    }
//
//                    if(navRight){
//                        navStepRight()
//                    }
                }
            });
        }
    }

    function live() {
        if (!config.longestStep) {
            console.warn('longestStep is zero!');
            config.longestStep = 300;
        }
        if (config.longestStep < 1) {
            config.longestStep = 1;
        }
        liveInterval = setInterval(function () {
            updateLive();
        }, Math.round(config.longestStep *1000));
    }

    function navStepLeft() {
        if (liveInterval) {
            clearInterval(liveInterval);
            liveInterval = undefined;
        }

        navStepMulti--;
        updateNav();
    }


    function navStepRight() {
        if (liveInterval) {
            clearInterval(liveInterval);
            liveInterval = undefined;
        }

        navStepMulti++;
        updateNav();
    }

    function NavNow() {
        seriesData = [];
        readData(true)

    }

    $("#navLeft").mousedown(function(){
        navLeft = true;
        navStepLeft();
    });

    $("#navRight").mousedown(function(){
        navRight = true;
        navStepRight();
    });

    $(window).mouseup(function(){
        navLeft = false;
       navRight = false;
    })

</script>

</body>
